class BondBase(Base):
    __abstract__ = True

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(50), nullable=True)
    face_value = Column(Float, nullable=True)
    maturity_date = Column(Date, nullable=True)
    issue_date = Column(Date, nullable=True)
    market_price = Column(Float, nullable=True)
    bond_type = Column(Enum(BondTypeEnum), nullable=True)
    settlement_date = Column(Date, nullable=True)
    credit_rating = Column(String(10), nullable=True)


class FixedRateBondModel(BondBase):
    __tablename__ = 'fixed_rate_bonds'
    coupon_rate = Column(Float, nullable=True)
    frequency = Column(Enum(CouponFrequencyEnum), nullable=True)
    coupon_schedule = Column(JSON, nullable=True)

    day_count_convention = Column(Enum(DayCountConventionEnum), nullable=True)



def test_fixed_rate_bond(self):
        bond = FixedRateBondModel(
            symbol="FIX001",
            face_value=1000,
            coupon_rate=0.06,
            frequency=CouponFrequencyEnum.SEMI_ANNUAL,
            issue_date=date(2020, 1, 1),
            maturity_date=date(2030, 1, 1),
            market_price=980,
            bond_type=BondTypeEnum.FIXED_COUPON,
            day_count_convention=DayCountConventionEnum.ACTUAL_360
        )
        analytics = bond_analytics_factory(bond)
        calculator = BondAnalyticsCalculator(analytics)

        print("\nFixed Rate Bond Analytics")
        print(f"{calculator.calculate()}")

def _to_ql_date(d: date) -> Date:
    return Date(d.day, d.month, d.year)


def _convert_day_count(dc_enum):
    return {
        DayCountConventionEnum.ACTUAL_360: Actual360(),
        DayCountConventionEnum.ACTUAL_365: ActualActual(),
        DayCountConventionEnum.THIRTY_360: Thirty360()
    }[dc_enum]


class BondAnalyticsBase:
    def __init__(self, bond: BondBase):
        self.symbol = bond.symbol
        self.face_value = bond.face_value
        self.maturity_date = _to_ql_date(bond.maturity_date)
        self.issue_date = _to_ql_date(bond.issue_date)
        self.market_price = bond.market_price
        self.bond_type = bond.bond_type
        self.settlement_date = _to_ql_date(bond.settlement_date) if bond.settlement_date else self.maturity_date
        self.credit_rating = bond.credit_rating
        self.calendar = TARGET()
        self.convention = Following


def bond_analytics_factory(bond: BondBase) -> BondAnalyticsBase:
    if bond.bond_type == BondTypeEnum.ZERO_COUPON:
        return ZeroCouponBondAnalytics(bond)
    elif bond.bond_type == BondTypeEnum.FIXED_COUPON:
        return FixedRateBondAnalytics(bond)
    elif bond.bond_type == BondTypeEnum.CALLABLE:
        return CallableBondAnalytics(bond)
    elif bond.bond_type == BondTypeEnum.PUTABLE:
        return PutableBondAnalytics(bond)
    elif bond.bond_type == BondTypeEnum.FLOATING:
        return FloatingRateBondAnalytics(bond)
    else:
        raise ValueError(f"Unsupported bond type: {bond.bond_type}")


class FixedRateBondAnalytics(BondAnalyticsBase):
    def __init__(self, bond: FixedRateBondModel):
        super().__init__(bond)
        self.coupon_rate = bond.coupon_rate
        self.frequency = bond.frequency
        self.day_count_convention = _convert_day_count(bond.day_count_convention)
        self.schedule = Schedule(
            self.issue_date,
            self.maturity_date,
            Period(int(12 / self.frequency.value), Months),
            self.calendar,
            self.convention,
            self.convention,
            DateGeneration.Backward,
            False
        )
        self.discount_curve = YieldTermStructureHandle(
            FlatForward(self.settlement_date, QuoteHandle(SimpleQuote(0.05)), self.day_count_convention)
        )
        self.bond = FixedRateBond(
            settlementDays=1,
            faceAmount=self.face_value,
            schedule=self.schedule,
            coupons=[self.coupon_rate],
            dayCounter=self.day_count_convention,
            paymentConvention=self.convention,
            redemption=100.0,
            issueDate=self.issue_date
        )



class BondAnalyticsCalculator:
    def __init__(self, bond_analytics):
        self.bond = bond_analytics.bond
        self.settlement_date = bond_analytics.settlement_date
        self.day_counter = bond_analytics.day_count_convention if bond_analytics.day_count_convention else None
        self.frequency = bond_analytics.frequency if bond_analytics.frequency else None
        self.market_price = bond_analytics.market_price

        self.call_schedule = getattr(bond_analytics, "call_schedule", None)
        self.put_schedule = getattr(bond_analytics, "put_schedule", None)

    def calculate(self) -> dict:
        # Yield to maturity (YTM) from actual market price
        ytm = self.bond.yieldToMaturity(self.market_price, self.day_counter, Compounded, self.frequency)

        # Precise cashflows
        clean_price = self.bond.cleanPrice(self.settlement_date, ytm, self.day_counter, Compounded, self.frequency)
        dirty_price = self.bond.dirtyPrice(self.settlement_date, ytm, self.day_counter, Compounded, self.frequency)
        accrued_interest = self.bond.accruedAmount(self.settlement_date)

        # High-precision durations
        mod_duration = self.bond.duration(ytm, Duration.Modified, self.day_counter, Compounded, self.frequency)
        mac_duration = self.bond.duration(ytm, Duration.Macaulay, self.day_counter, Compounded, self.frequency)
        simple_duration = self.bond.duration(ytm, Duration.Simple, self.day_counter, Compounded, self.frequency)

        # Convexity
        convexity = self.bond.convexity(ytm, self.day_counter, Compounded, self.frequency)

        # DV01 via perturbation method
        dv01 = self._dv01_perturbation(ytm)

        # Yield to Worst from call/put/maturity schedule
        ytw = self._yield_to_worst(clean_price)

        # Get the cashflows
        cashflows = self.cashflows()

        return {
            "clean_price": clean_price,
            "dirty_price": dirty_price,
            "accrued_interest": accrued_interest,
            "yield_to_maturity": ytm,
            "yield_to_worst": ytw,
            "modified_duration": mod_duration,
            "macaulay_duration": mac_duration,
            "simple_duration": simple_duration,
            "convexity": convexity,
            "dv01": dv01,
            "cashflows": cashflows
        }

    def cashflows(self):
        return [
            (cf.date().ISO(), cf.amount())
            for cf in self.bond.cashflows()
            if cf.date() >= self.settlement_date
        ]

    def _dv01_perturbation(self, ytm: float) -> float:
        """
        Calculates DV01 by perturbing yield Â±1bp and computing price difference.
        """
        bumped_up = self.bond.cleanPrice(self.settlement_date, ytm + 0.0001, self.day_counter, Compounded,
                                         self.frequency)
        bumped_down = self.bond.cleanPrice(self.settlement_date, ytm - 0.0001, self.day_counter, Compounded,
                                           self.frequency)
        return (bumped_down - bumped_up) / 2  # Per 1bp

    def _yield_to_worst(self, clean_price: float) -> float:
        """
        Computes the lowest yield (YTW) from call, put, and maturity dates.
        """
        yields = []

        def _to_ql_date_str(d: str) -> Date:
            from datetime import date as dt
            parts = dt.fromisoformat(d)
            return Date(parts.day, parts.month, parts.year)

        def try_yield(date_obj):
            return self.bond.yieldToMaturity(clean_price, self.day_counter, Compounded, self.frequency, date_obj)

        if self.call_schedule:
            for entry in self.call_schedule:
                call_date = _to_ql_date_str(entry["date"])
                result = try_yield(call_date)
                if result is not None:
                    yields.append(result)

        if self.put_schedule:
            for entry in self.put_schedule:
                put_date = _to_ql_date_str(entry["date"])
                result = try_yield(put_date)
                if result is not None:
                    yields.append(result)

        # Always include maturity YTM
        try:
            maturity_ytm = self.bond.yieldToMaturity(clean_price, self.day_counter, Compounded, self.frequency)
            yields.append(maturity_ytm)
        except:
            pass

        return min(yields) if yields else None
